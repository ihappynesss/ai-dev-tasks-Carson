{
  "name": "Main Ticket Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "freshdesk-ticket",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-receiver",
      "name": "Webhook - New Ticket",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        250,
        300
      ],
      "webhookId": "freshdesk-new-ticket"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"status\": \"received\", \"ticket_id\": $json.ticket.id, \"timestamp\": new Date().toISOString()} }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "immediate-response",
      "name": "Immediate Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.headers['x-freshdesk-signature'] }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "verify-signature",
      "name": "Verify Webhook Signature",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Verify HMAC-SHA256 signature from Freshdesk\nconst crypto = require('crypto');\n\nconst webhookSecret = $env.FRESHDESK_WEBHOOK_SECRET || 'your-webhook-secret';\nconst signature = $json.headers['x-freshdesk-signature'];\nconst payload = JSON.stringify($json.body);\n\n// Calculate expected signature\nconst expectedSignature = crypto\n  .createHmac('sha256', webhookSecret)\n  .update(payload)\n  .digest('base64');\n\n// Verify signature\nconst isValid = signature === expectedSignature;\n\nif (!isValid) {\n  throw new Error('Invalid webhook signature');\n}\n\nreturn $json;"
      },
      "id": "signature-verification",
      "name": "HMAC Signature Verification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        850,
        250
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.body.ticket.id }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "options": {
          "timeout": 10000
        }
      },
      "id": "get-ticket-details",
      "name": "Freshdesk - Get Ticket",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1050,
        250
      ]
    },
    {
      "parameters": {
        "functionCode": "// Normalize and enrich ticket text\nconst ticket = $json;\n\n// Remove HTML tags\nfunction stripHtml(html) {\n  if (!html) return '';\n  return html.replace(/<[^>]*>/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .trim();\n}\n\n// Extract NSW strata entities using regex\nfunction extractEntities(text) {\n  const entities = {\n    propertyAddresses: [],\n    lotNumbers: [],\n    strataPlanNumbers: [],\n    legislationReferences: [],\n    bylawNumbers: []\n  };\n\n  // Australian street addresses\n  const addressRegex = /\\d+\\s+[A-Za-z\\s]+(?:Street|St|Road|Rd|Avenue|Ave|Drive|Dr|Court|Ct|Place|Pl|Terrace|Tce|Parade|Pde|Boulevard|Blvd|Lane|Ln|Way|Highway|Hwy|Crescent|Cres),?\\s*(?:[A-Za-z\\s]+)?(?:NSW)?\\s*\\d{4}/gi;\n  entities.propertyAddresses = text.match(addressRegex) || [];\n\n  // Lot numbers (e.g., \"Lot 23\", \"Unit 5\", \"Apartment 12\")\n  const lotRegex = /(?:Lot|Unit|Apartment|Apt)\\s*#?\\s*(\\d+)/gi;\n  const lotMatches = text.matchAll(lotRegex);\n  for (const match of lotMatches) {\n    entities.lotNumbers.push(match[0]);\n  }\n\n  // Strata plan numbers (e.g., \"SP 12345\", \"Strata Plan 54321\")\n  const planRegex = /(?:SP|Strata\\s+Plan)\\s*#?\\s*(\\d+)/gi;\n  const planMatches = text.matchAll(planRegex);\n  for (const match of planMatches) {\n    entities.strataPlanNumbers.push(match[0]);\n  }\n\n  // NSW legislation references (e.g., \"SSMA 2015 Section 106\", \"Section 132 SSDA 2015\")\n  const legislationRegex = /(?:SSMA|SSDA)\\s*\\d{4}(?:\\s+Section\\s+\\d+)?|Section\\s+\\d+\\s+(?:SSMA|SSDA)\\s*\\d{4}/gi;\n  entities.legislationReferences = text.match(legislationRegex) || [];\n\n  // By-law numbers (e.g., \"By-law 3\", \"Model By-law 7\")\n  const bylawRegex = /(?:Model\\s+)?By-law\\s+#?\\s*(\\d+)/gi;\n  const bylawMatches = text.matchAll(bylawRegex);\n  for (const match of bylawMatches) {\n    entities.bylawNumbers.push(match[0]);\n  }\n\n  return entities;\n}\n\n// Extract keywords for NSW strata categories\nfunction extractKeywords(text) {\n  const keywords = {\n    maintenanceRepairs: ['roof', 'leak', 'plumbing', 'lift', 'elevator', 'repair', 'maintenance', 'damage', 'broken', 'malfunction', 'emergency'],\n    bylawCompliance: ['noise', 'parking', 'pet', 'dog', 'cat', 'smoking', 'rubbish', 'garbage', 'airbnb', 'short-term', 'letting', 'nuisance'],\n    financial: ['levy', 'levies', 'fee', 'payment', 'overdue', 'arrears', 'budget', 'insurance', 'claim'],\n    governance: ['meeting', 'AGM', 'EGM', 'committee', 'minutes', 'vote', 'resolution', 'quorum', 'by-law', 'bylaw'],\n    renovations: ['renovation', 'flooring', 'kitchen', 'bathroom', 'paint', 'tile', 'approval', 'alteration', 'work'],\n    disputes: ['complaint', 'dispute', 'NCAT', 'tribunal', 'mediation', 'conflict', 'neighbor', 'neighbour'],\n    security: ['security', 'access', 'CCTV', 'camera', 'safety', 'fire', 'hazard', 'lock', 'key'],\n    information: ['information', 'records', 'documents', 'certificate', 'strata plan', 'onboarding']\n  };\n\n  const lowerText = text.toLowerCase();\n  const matchedCategories = [];\n\n  for (const [category, words] of Object.entries(keywords)) {\n    for (const word of words) {\n      if (lowerText.includes(word.toLowerCase())) {\n        matchedCategories.push(category);\n        break;\n      }\n    }\n  }\n\n  return matchedCategories;\n}\n\n// Clean and concatenate subject + description\nconst subject = stripHtml(ticket.subject || '');\nconst description = stripHtml(ticket.description || '');\nconst normalizedText = `${subject}\\n\\n${description}`.trim();\n\n// Extract entities and keywords\nconst entities = extractEntities(normalizedText);\nconst categoryHints = extractKeywords(normalizedText);\n\n// Determine priority\nconst priorityMap = {\n  1: 'low',\n  2: 'medium',\n  3: 'high',\n  4: 'urgent'\n};\n\n// Build enriched ticket object\nconst enrichedTicket = {\n  // Original ticket data\n  ticketId: ticket.id,\n  subject: subject,\n  description: description,\n  normalizedText: normalizedText,\n  \n  // Metadata\n  priority: priorityMap[ticket.priority] || 'medium',\n  status: ticket.status,\n  created_at: ticket.created_at,\n  updated_at: ticket.updated_at,\n  due_by: ticket.due_by,\n  fr_due_by: ticket.fr_due_by,\n  \n  // Requester information\n  requester: {\n    id: ticket.requester_id,\n    name: ticket.requester?.name || null,\n    email: ticket.requester?.email || ticket.email || null,\n    phone: ticket.requester?.phone || null\n  },\n  \n  // Custom fields (property-specific)\n  customFields: ticket.custom_fields || {},\n  \n  // Extracted entities\n  entities: entities,\n  \n  // Category hints for classification\n  categoryHints: categoryHints,\n  \n  // Tags\n  tags: ticket.tags || [],\n  \n  // Attachments\n  hasAttachments: (ticket.attachments && ticket.attachments.length > 0),\n  attachmentCount: ticket.attachments?.length || 0,\n  \n  // Processing metadata\n  processingTimestamp: new Date().toISOString(),\n  textLength: normalizedText.length,\n  \n  // Full ticket object for reference\n  _original: ticket\n};\n\nreturn enrichedTicket;"
      },
      "id": "normalize-extract",
      "name": "Normalize and Extract Entities",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1250,
        250
      ]
    },
    {
      "parameters": {
        "functionCode": "// Task 8.0: NSW Strata Categorization System\n// This node implements comprehensive NSW strata ticket categorization\n// with 8 primary categories, subcategories, priority logic, and compliance tracking\n\nfunction categorizeNSWStrataTicket(ticket) {\n  const text = ticket.normalizedText.toLowerCase();\n  const entities = ticket.entities;\n\n  // Task 8.2-8.9: Define all 8 primary categories with subcategories and keywords\n  const categories = {\n    // Task 8.2: Maintenance & Repairs\n    maintenanceRepairs: {\n      name: 'Maintenance & Repairs',\n      priority: 'high', // Default, will be refined\n      subcategories: {\n        commonProperty: {\n          keywords: ['roof', 'leak', 'common area', 'lobby', 'hallway', 'stairwell', 'facade', 'building exterior', 'common wall', 'shared'],\n          examples: ['roof leak', 'common area damage', 'lobby repair']\n        },\n        systems: {\n          keywords: ['lift', 'elevator', 'plumbing', 'electrical', 'hvac', 'air conditioning', 'heating', 'ventilation', 'hot water', 'water system'],\n          examples: ['lift malfunction', 'plumbing issue', 'electrical fault']\n        },\n        emergency: {\n          keywords: ['emergency', 'urgent', 'immediate', 'critical', 'dangerous', 'hazardous', 'safety risk', 'flood', 'gas leak', 'power outage'],\n          examples: ['emergency repair', 'gas leak', 'flood damage'],\n          priorityOverride: 'critical'\n        },\n        amenities: {\n          keywords: ['pool', 'gym', 'sauna', 'bbq', 'garden', 'playground', 'tennis court', 'recreation', 'amenity'],\n          examples: ['pool maintenance', 'gym equipment', 'garden repair']\n        },\n        defects: {\n          keywords: ['defect', 'warranty', 'building defect', 'structural', 'crack', 'water ingress', 'mould', 'mold'],\n          examples: ['building defect', 'structural issue', 'water damage']\n        }\n      }\n    },\n\n    // Task 8.3: By-Law Compliance\n    bylawCompliance: {\n      name: 'By-Law Compliance',\n      priority: 'medium',\n      subcategories: {\n        noise: {\n          keywords: ['noise', 'loud', 'noisy', 'disturbance', 'party', 'music', 'tv', 'construction noise', 'late night', 'barking'],\n          examples: ['noise complaint', 'loud music', 'late night disturbance'],\n          bylaws: [1, 2] // Model By-laws 1 & 2\n        },\n        parking: {\n          keywords: ['parking', 'car', 'vehicle', 'garage', 'car space', 'visitor parking', 'unauthorized parking'],\n          examples: ['parking violation', 'unauthorized vehicle'],\n          bylaws: [7] // Model By-law 7\n        },\n        pets: {\n          keywords: ['pet', 'dog', 'cat', 'animal', 'pet approval', 'barking dog'],\n          examples: ['unauthorized pet', 'pet complaint'],\n          bylaws: [8] // Model By-law 8\n        },\n        smoking: {\n          keywords: ['smoking', 'smoke', 'cigarette', 'tobacco', 'vaping'],\n          examples: ['smoking complaint', 'secondhand smoke'],\n          bylaws: [5] // Model By-law 5\n        },\n        rubbish: {\n          keywords: ['rubbish', 'garbage', 'waste', 'trash', 'recycling', 'bin'],\n          examples: ['rubbish disposal', 'garbage issue'],\n          bylaws: [4] // Model By-law 4\n        },\n        shortTermLetting: {\n          keywords: ['airbnb', 'short-term', 'short term', 'rental', 'letting', 'holiday rental', 'accommodation'],\n          examples: ['Airbnb complaint', 'short-term letting'],\n          bylaws: [14], // Model By-law 14\n          priorityOverride: 'high'\n        },\n        nuisance: {\n          keywords: ['nuisance', 'disturbance', 'antisocial', 'harassment', 'behavior', 'behaviour'],\n          examples: ['nuisance complaint', 'antisocial behavior'],\n          bylaws: [3] // Model By-law 3\n        }\n      }\n    },\n\n    // Task 8.4: Financial Matters\n    financialMatters: {\n      name: 'Financial Matters',\n      priority: 'medium',\n      subcategories: {\n        levies: {\n          keywords: ['levy', 'levies', 'strata levy', 'admin fund', 'sinking fund', 'capital works fund', 'overdue', 'arrears', 'payment plan'],\n          examples: ['unpaid levies', 'levy arrears', 'payment plan'],\n          legislation: ['SSMA 2015 Section 85-86']\n        },\n        disputes: {\n          keywords: ['financial dispute', 'levy dispute', 'charge dispute', 'cost dispute', 'billing error'],\n          examples: ['disputed levy', 'incorrect charge'],\n          legislation: ['SSMA 2015 Section 232']\n        },\n        statements: {\n          keywords: ['financial statement', 'levy notice', 'statement', 'invoice', 'account', 'balance'],\n          examples: ['request statement', 'levy notice inquiry']\n        },\n        insurance: {\n          keywords: ['insurance', 'claim', 'building insurance', 'contents insurance', 'public liability', 'strata insurance'],\n          examples: ['insurance claim', 'insurance inquiry'],\n          legislation: ['SSMA 2015 Section 160-162']\n        }\n      }\n    },\n\n    // Task 8.5: Governance & Administration\n    governanceAdministration: {\n      name: 'Governance & Administration',\n      priority: 'medium',\n      subcategories: {\n        meetings: {\n          keywords: ['agm', 'annual general meeting', 'egm', 'extraordinary general meeting', 'general meeting', 'meeting', 'notice', 'agenda', 'minutes'],\n          examples: ['AGM inquiry', 'meeting notice', 'minutes request'],\n          legislation: ['SSMA 2015 Section 18-31']\n        },\n        committees: {\n          keywords: ['committee', 'strata committee', 'executive committee', 'nomination', 'election'],\n          examples: ['committee nomination', 'committee inquiry'],\n          legislation: ['SSMA 2015 Section 32-45']\n        },\n        bylaws: {\n          keywords: ['by-law', 'bylaw', 'strata by-law', 'model by-law', 'by-law change', 'special resolution'],\n          examples: ['by-law inquiry', 'change by-law'],\n          legislation: ['SSMA 2015 Section 136-151']\n        },\n        records: {\n          keywords: ['records', 'documents', 'strata records', 'roll', 'register', 'inspection', 'access'],\n          examples: ['access records', 'document request'],\n          legislation: ['SSMA 2015 Section 178-183']\n        },\n        compliance: {\n          keywords: ['compliance', 'regulation', 'requirement', 'obligation', 'duty', 'responsibility'],\n          examples: ['compliance inquiry', 'legal obligation'],\n          legislation: ['SSMA 2015', 'SSDA 2015']\n        }\n      }\n    },\n\n    // Task 8.6: Renovations & Alterations (Three-tier system)\n    renovationsAlterations: {\n      name: 'Renovations & Alterations',\n      priority: 'medium',\n      subcategories: {\n        cosmetic: {\n          keywords: ['paint', 'carpet', 'curtain', 'blind', 'cosmetic', 'internal painting', 'floor covering'],\n          examples: ['painting request', 'carpet replacement'],\n          approvalRequired: false,\n          legislation: ['SSMA 2015 Section 109'] // Cosmetic work definition\n        },\n        minor: {\n          keywords: ['flooring', 'timber floor', 'laminate', 'tile', 'kitchen', 'bathroom', 'minor renovation', 'internal alteration'],\n          examples: ['timber flooring', 'kitchen renovation'],\n          approvalRequired: true,\n          approvalType: 'committee',\n          legislation: ['SSMA 2015 Section 108-110']\n        },\n        major: {\n          keywords: ['structural', 'major renovation', 'wall removal', 'balcony', 'window', 'external', 'major alteration', 'building work'],\n          examples: ['structural change', 'balcony enclosure'],\n          approvalRequired: true,\n          approvalType: 'general_meeting_special_resolution',\n          priorityOverride: 'high',\n          legislation: ['SSMA 2015 Section 108', 'SSDA 2015']\n        }\n      }\n    },\n\n    // Task 8.7: Disputes & Complaints\n    disputesComplaints: {\n      name: 'Disputes & Complaints',\n      priority: 'high',\n      subcategories: {\n        neighbor: {\n          keywords: ['neighbor', 'neighbour', 'lot owner', 'resident', 'tenant', 'dispute with neighbor'],\n          examples: ['neighbor dispute', 'resident complaint']\n        },\n        ownersCorporation: {\n          keywords: ['owners corporation', 'oc dispute', 'strata scheme', 'body corporate'],\n          examples: ['dispute with OC', 'OC complaint']\n        },\n        strataManager: {\n          keywords: ['strata manager', 'managing agent', 'property manager', 'manager complaint'],\n          examples: ['strata manager complaint', 'service issue']\n        },\n        ncat: {\n          keywords: ['ncat', 'tribunal', 'civil and administrative tribunal', 'mediation', 'hearing', 'application', 'order'],\n          examples: ['NCAT application', 'tribunal matter'],\n          priorityOverride: 'critical',\n          legislation: ['SSMA 2015 Section 232-240']\n        }\n      }\n    },\n\n    // Task 8.8: Security & Safety\n    securitySafety: {\n      name: 'Security & Safety',\n      priority: 'high',\n      subcategories: {\n        access: {\n          keywords: ['access', 'entry', 'intercom', 'key', 'fob', 'lock', 'security gate', 'access control'],\n          examples: ['access issue', 'key request', 'intercom fault']\n        },\n        cctv: {\n          keywords: ['cctv', 'camera', 'surveillance', 'security camera', 'recording', 'privacy'],\n          examples: ['CCTV inquiry', 'camera installation'],\n          legislation: ['Privacy Act 1988']\n        },\n        hazards: {\n          keywords: ['hazard', 'dangerous', 'unsafe', 'safety concern', 'risk', 'trip hazard'],\n          examples: ['safety hazard', 'unsafe condition'],\n          priorityOverride: 'critical'\n        },\n        fireSafety: {\n          keywords: ['fire', 'fire safety', 'smoke alarm', 'fire alarm', 'extinguisher', 'fire exit', 'emergency exit', 'evacuation'],\n          examples: ['fire safety issue', 'smoke alarm'],\n          priorityOverride: 'critical',\n          legislation: ['Environmental Planning and Assessment Regulation 2021']\n        },\n        windowSafety: {\n          keywords: ['window', 'window safety', 'balustrade', 'railing', 'fall prevention', 'child safety'],\n          examples: ['window safety', 'balustrade issue'],\n          legislation: ['SSMA 2015 Section 106'] // Window safety devices\n        }\n      }\n    },\n\n    // Task 8.9: Information Requests\n    informationRequests: {\n      name: 'Information Requests',\n      priority: 'low',\n      subcategories: {\n        general: {\n          keywords: ['information', 'inquiry', 'question', 'how to', 'what is', 'general inquiry', 'clarification'],\n          examples: ['general inquiry', 'information request']\n        },\n        onboarding: {\n          keywords: ['new owner', 'new tenant', 'move in', 'moving in', 'onboarding', 'welcome', 'first time'],\n          examples: ['new owner inquiry', 'moving in information']\n        },\n        vendor: {\n          keywords: ['vendor', 'contractor', 'tradesperson', 'approved contractor', 'service provider'],\n          examples: ['contractor inquiry', 'vendor list request']\n        }\n      }\n    }\n  };\n\n  // Task 8.14: Keyword-based initial classification\n  function performKeywordClassification() {\n    const scores = {};\n\n    // Score each category based on keyword matches\n    for (const [categoryKey, category] of Object.entries(categories)) {\n      scores[categoryKey] = { score: 0, subcategory: null, matchedKeywords: [] };\n\n      for (const [subcatKey, subcat] of Object.entries(category.subcategories)) {\n        let subcatScore = 0;\n        const matched = [];\n\n        for (const keyword of subcat.keywords) {\n          if (text.includes(keyword.toLowerCase())) {\n            subcatScore += 1;\n            matched.push(keyword);\n          }\n        }\n\n        if (subcatScore > scores[categoryKey].score) {\n          scores[categoryKey] = {\n            score: subcatScore,\n            subcategory: subcatKey,\n            matchedKeywords: matched,\n            subcategoryData: subcat\n          };\n        }\n      }\n    }\n\n    // Find best match\n    let bestCategory = null;\n    let bestScore = 0;\n\n    for (const [categoryKey, data] of Object.entries(scores)) {\n      if (data.score > bestScore) {\n        bestScore = data.score;\n        bestCategory = {\n          category: categoryKey,\n          categoryName: categories[categoryKey].name,\n          ...data\n        };\n      }\n    }\n\n    return bestCategory;\n  }\n\n  // Task 8.15: Complexity scoring (1-5)\n  function calculateComplexityScore(classification) {\n    let complexity = 1; // Base complexity\n\n    // Factor 1: Multiple entity types mentioned\n    const entityCount =\n      (entities.propertyAddresses?.length || 0) +\n      (entities.lotNumbers?.length || 0) +\n      (entities.strataPlanNumbers?.length || 0) +\n      (entities.legislationReferences?.length || 0) +\n      (entities.bylawNumbers?.length || 0);\n\n    if (entityCount > 3) complexity += 1;\n\n    // Factor 2: Multiple keywords matched\n    if (classification && classification.score > 5) complexity += 1;\n\n    // Factor 3: Category-specific complexity\n    if (classification) {\n      const complexCategories = ['disputesComplaints', 'renovationsAlterations', 'governanceAdministration'];\n      if (complexCategories.includes(classification.category)) complexity += 1;\n\n      // NCAT matters are always complex\n      if (classification.subcategory === 'ncat') complexity = 5;\n\n      // Major renovations are complex\n      if (classification.subcategory === 'major') complexity += 1;\n    }\n\n    // Factor 4: Text length (longer = potentially more complex)\n    if (ticket.textLength > 500) complexity += 1;\n\n    // Factor 5: Legislation references (indicates legal complexity)\n    if (entities.legislationReferences?.length > 0) complexity += 1;\n\n    // Cap at 5\n    return Math.min(complexity, 5);\n  }\n\n  // Task 8.15: Stakeholder type identification\n  function identifyStakeholders(classification) {\n    const stakeholders = {\n      ownersCorporation: false,\n      strataCommittee: false,\n      strataManager: false,\n      lotOwner: true, // Always involved (requester)\n      tenant: false,\n      contractor: false,\n      thirdParty: false\n    };\n\n    // Identify from text\n    if (text.includes('tenant') || text.includes('renter')) stakeholders.tenant = true;\n    if (text.includes('contractor') || text.includes('tradesperson')) stakeholders.contractor = true;\n    if (text.includes('neighbor') || text.includes('neighbour')) stakeholders.thirdParty = true;\n\n    // Category-based stakeholders\n    if (classification) {\n      const category = classification.category;\n\n      // OC always involved in financial, governance, and major works\n      if (['financialMatters', 'governanceAdministration'].includes(category)) {\n        stakeholders.ownersCorporation = true;\n        stakeholders.strataCommittee = true;\n        stakeholders.strataManager = true;\n      }\n\n      // Committee approval required for minor renovations\n      if (category === 'renovationsAlterations' && classification.subcategory === 'minor') {\n        stakeholders.strataCommittee = true;\n      }\n\n      // Major works require OC approval\n      if (category === 'renovationsAlterations' && classification.subcategory === 'major') {\n        stakeholders.ownersCorporation = true;\n        stakeholders.strataCommittee = true;\n      }\n\n      // Maintenance typically involves strata manager\n      if (category === 'maintenanceRepairs') {\n        stakeholders.strataManager = true;\n        if (classification.subcategory === 'emergency') {\n          stakeholders.contractor = true;\n        }\n      }\n    }\n\n    return stakeholders;\n  }\n\n  // Task 8.10: Priority assignment logic\n  function assignPriority(classification, complexity) {\n    // Task 8.10: Critical priority (same-day per SSMA Section 106)\n    if (classification && classification.subcategoryData?.priorityOverride === 'critical') {\n      return {\n        level: 'critical',\n        responseTime: '4 hours', // Same business day\n        dueBy: addHours(new Date(), 4),\n        legislation: 'SSMA 2015 Section 106'\n      };\n    }\n\n    // Emergency repairs\n    if (classification?.subcategory === 'emergency') {\n      return {\n        level: 'critical',\n        responseTime: '4 hours',\n        dueBy: addHours(new Date(), 4),\n        legislation: 'SSMA 2015 Section 106'\n      };\n    }\n\n    // High priority (4-hour response)\n    if (classification?.subcategoryData?.priorityOverride === 'high' ||\n        ticket.priority === 'urgent' ||\n        complexity >= 4) {\n      return {\n        level: 'high',\n        responseTime: '4 hours',\n        dueBy: addHours(new Date(), 4)\n      };\n    }\n\n    // Medium priority (1 business day)\n    if (classification?.category === 'bylawCompliance' ||\n        classification?.category === 'maintenanceRepairs' ||\n        complexity === 3) {\n      return {\n        level: 'medium',\n        responseTime: '1 business day',\n        dueBy: addBusinessDays(new Date(), 1)\n      };\n    }\n\n    // Low priority (2 business days)\n    return {\n      level: 'low',\n      responseTime: '2 business days',\n      dueBy: addBusinessDays(new Date(), 2)\n    };\n  }\n\n  // Helper functions\n  function addHours(date, hours) {\n    const result = new Date(date);\n    result.setHours(result.getHours() + hours);\n    return result.toISOString();\n  }\n\n  function addBusinessDays(date, days) {\n    const result = new Date(date);\n    let addedDays = 0;\n\n    while (addedDays < days) {\n      result.setDate(result.getDate() + 1);\n      // Skip weekends\n      if (result.getDay() !== 0 && result.getDay() !== 6) {\n        addedDays++;\n      }\n    }\n\n    return result.toISOString();\n  }\n\n  // Main classification process\n  const classification = performKeywordClassification();\n  const complexity = calculateComplexityScore(classification);\n  const stakeholders = identifyStakeholders(classification);\n  const priority = assignPriority(classification, complexity);\n\n  // Task 8.11: Legislation references\n  const legislationReferences = [];\n  if (classification && classification.subcategoryData?.legislation) {\n    legislationReferences.push(...classification.subcategoryData.legislation);\n  }\n  // Add extracted legislation from ticket text\n  if (entities.legislationReferences?.length > 0) {\n    legislationReferences.push(...entities.legislationReferences);\n  }\n\n  // Task 8.12: By-laws references\n  const bylawReferences = [];\n  if (classification && classification.subcategoryData?.bylaws) {\n    bylawReferences.push(...classification.subcategoryData.bylaws);\n  }\n  // Add extracted by-laws from ticket text\n  if (entities.bylawNumbers?.length > 0) {\n    bylawReferences.push(...entities.bylawNumbers);\n  }\n\n  // Task 8.13: Check for 2025 reforms applicability\n  const reforms2025 = {\n    capitalWorksPlanning: false,\n    disclosureObligations: false,\n    accessibilityApprovals: false\n  };\n\n  if (classification?.category === 'renovationsAlterations' && classification?.subcategory === 'major') {\n    reforms2025.accessibilityApprovals = true;\n  }\n  if (classification?.category === 'governanceAdministration') {\n    reforms2025.capitalWorksPlanning = true;\n    reforms2025.disclosureObligations = true;\n  }\n  if (text.includes('capital works') || text.includes('10 year plan')) {\n    reforms2025.capitalWorksPlanning = true;\n  }\n\n  // Return comprehensive categorization result\n  return {\n    // Primary classification\n    primaryCategory: classification?.categoryName || 'Uncategorized',\n    primaryCategoryKey: classification?.category || null,\n    subcategory: classification?.subcategory || null,\n    subcategoryName: classification?.subcategoryData?.examples?.[0] || null,\n\n    // Scoring\n    matchScore: classification?.score || 0,\n    matchedKeywords: classification?.matchedKeywords || [],\n    confidence: classification ? Math.min(classification.score / 10, 1.0) : 0,\n\n    // Task 8.15: Complexity and stakeholders\n    complexity: complexity,\n    complexityDescription: ['Very Simple', 'Simple', 'Moderate', 'Complex', 'Very Complex'][complexity - 1],\n    stakeholders: stakeholders,\n    stakeholderCount: Object.values(stakeholders).filter(Boolean).length,\n\n    // Task 8.10: Priority\n    priority: priority,\n\n    // Task 8.11: Legislation\n    legislationReferences: [...new Set(legislationReferences)],\n\n    // Task 8.12: By-laws\n    bylawReferences: [...new Set(bylawReferences)],\n\n    // Task 8.13: 2025 reforms\n    reforms2025: reforms2025,\n\n    // Approval requirements (for renovations)\n    approvalRequired: classification?.subcategoryData?.approvalRequired || false,\n    approvalType: classification?.subcategoryData?.approvalType || null,\n\n    // Metadata\n    classificationTimestamp: new Date().toISOString(),\n    classificationMethod: classification && classification.score > 2 ? 'keyword-match' : 'fallback-required'\n  };\n}\n\n// Export for n8n Code node\nconst categorization = categorizeNSWStrataTicket($json);\n\n// Merge categorization with ticket data\nreturn {\n  ...$json,\n  categorization: categorization,\n  // Update priority based on categorization if different\n  priority: categorization.priority?.level || $json.priority,\n  // Add category tag\n  tags: [...($json.tags || []), categorization.primaryCategory.toLowerCase().replace(/\\s+/g, '-')],\n  // Add complexity to custom fields\n  customFields: {\n    ...$json.customFields,\n    complexity: categorization.complexity,\n    primaryCategory: categorization.primaryCategory,\n    subcategory: categorization.subcategory\n  }\n};\n"
      },
      "id": "nsw-categorization",
      "name": "NSW Strata Categorization",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1350,
        250
      ],
      "notes": "Task 8.0: Comprehensive NSW strata categorization with 8 categories, subcategories, priority logic, and compliance tracking"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.textLength }}",
              "operation": "largerEqual",
              "value2": 10
            }
          ],
          "boolean": [
            {
              "value1": "={{ $json.ticketId !== undefined }}",
              "value2": true
            }
          ]
        }
      },
      "id": "validate-ticket",
      "name": "Validate Ticket Data",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1450,
        250
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.OPENAI_API_URL || 'https://api.openai.com' }}/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.OPENAI_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "specifyBody": "json",
        "jsonBody": "={{ {\"model\": \"text-embedding-3-small\", \"input\": $json.normalizedText} }}",
        "options": {}
      },
      "id": "generate-embedding",
      "name": "Generate Embedding (OpenAI)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1650,
        200
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Hybrid search with lazy loading (summaries only)\n-- Task 4.14: Only fetch id, title, summary initially for performance\nWITH vector_search AS (\n  SELECT\n    id,\n    title,\n    metadata,\n    embedding <-> $1::vector AS distance,\n    1 - (embedding <-> $1::vector) AS similarity\n  FROM knowledge_base\n  WHERE metadata->>'status' = 'active'\n    -- Optional category filter\n    -- AND metadata->>'category' = $2\n  ORDER BY distance\n  LIMIT 10\n),\nkeyword_search AS (\n  SELECT\n    id,\n    title,\n    metadata,\n    similarity(COALESCE(metadata->>'summary', ''), $2) AS keyword_score\n  FROM knowledge_base\n  WHERE metadata->>'status' = 'active'\n    AND (COALESCE(metadata->>'summary', '') % $2 OR title % $2)\n  ORDER BY keyword_score DESC\n  LIMIT 10\n)\n-- Reciprocal Rank Fusion\nSELECT\n  kb.id,\n  kb.title,\n  kb.metadata->>'summary' AS summary,\n  kb.metadata->>'category' AS category,\n  kb.metadata->>'success_rate' AS success_rate,\n  kb.metadata,\n  COALESCE(vs.similarity, 0) AS vector_similarity,\n  COALESCE(ks.keyword_score, 0) AS keyword_score,\n  (\n    COALESCE(1.0 / (60 + vs_rank), 0) +\n    COALESCE(1.0 / (60 + ks_rank), 0)\n  ) AS combined_score\nFROM knowledge_base kb\nLEFT JOIN (\n  SELECT id, similarity, ROW_NUMBER() OVER (ORDER BY distance) AS vs_rank\n  FROM vector_search\n) vs ON kb.id = vs.id\nLEFT JOIN (\n  SELECT id, keyword_score, ROW_NUMBER() OVER (ORDER BY keyword_score DESC) AS ks_rank\n  FROM keyword_search\n) ks ON kb.id = ks.id\nWHERE vs.id IS NOT NULL OR ks.id IS NOT NULL\nORDER BY combined_score DESC\nLIMIT 5;",
        "options": {
          "queryReplacement": "={{ [$json.embedding, $json.normalizedText] }}",
          "nodeErrorWorkflow": "fallback-keyword-search"
        }
      },
      "id": "hybrid-search",
      "name": "Hybrid Search (Vector + Keyword)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1850,
        200
      ],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Task 4.15: Fallback keyword-only search when vector search fails\n-- Uses only pg_trgm trigram similarity for keyword matching\nSELECT\n  id,\n  title,\n  metadata->>'summary' AS summary,\n  metadata->>'category' AS category,\n  metadata->>'success_rate' AS success_rate,\n  metadata,\n  0 AS vector_similarity,\n  similarity(COALESCE(metadata->>'summary', title), $1) AS keyword_score,\n  similarity(COALESCE(metadata->>'summary', title), $1) AS combined_score\nFROM knowledge_base\nWHERE metadata->>'status' = 'active'\n  AND (COALESCE(metadata->>'summary', '') % $1 OR title % $1)\nORDER BY keyword_score DESC\nLIMIT 5;",
        "options": {
          "queryReplacement": "={{ [$json.normalizedText] }}"
        }
      },
      "id": "fallback-keyword-search",
      "name": "Fallback: Keyword-Only Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1850,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Fallback search when hybrid search fails - uses trigram similarity only"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-ticket-knowledge",
      "name": "Merge Ticket + Knowledge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        2050,
        250
      ]
    },
    {
      "parameters": {
        "functionCode": "// Calculate confidence score and route decision\\nconst ticket = $input.first().json;\\nconst knowledgeEntries = $input.last().json;\\n\\n// Get highest similarity score\\nconst highestSimilarity = knowledgeEntries.length > 0 \\n  ? Math.max(...knowledgeEntries.map(k => k.vector_similarity || 0))\\n  : 0;\\n\\n// Count training samples for this category (simulated - would query training_examples table)\\nconst trainingSamples = 50; // TODO: Query actual training samples count\\n\\n// Determine routing path\\nlet routingPath = 'unknown';\\nlet requiresHumanReview = false;\\n\\nif (ticket.priority === 'urgent' || ticket.customFields?.complexity > 4) {\\n  routingPath = 'immediate-escalation';\\n  requiresHumanReview = true;\\n} else if (highestSimilarity > 0.85 && trainingSamples > 100 && !requiresHumanReview) {\\n  routingPath = 'auto-respond';\\n} else if (highestSimilarity >= 0.75 && highestSimilarity <= 0.85 && trainingSamples > 100) {\\n  routingPath = 'auto-refine';\\n} else if (highestSimilarity >= 0.50 && highestSimilarity < 0.75 && trainingSamples > 30) {\\n  routingPath = 'generate-draft';\\n} else if (highestSimilarity < 0.50) {\\n  routingPath = 'deep-research';\\n}\\n\\nreturn {\\n  ticket: ticket,\\n  knowledge: knowledgeEntries,\\n  routing: {\\n    path: routingPath,\\n    confidence: highestSimilarity,\\n    trainingSamples: trainingSamples,\\n    requiresHumanReview: requiresHumanReview,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
      },
      "id": "decision-engine",
      "name": "Decision Engine - Routing Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2250,
        250
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.routing.path }}",
              "value2": "auto-respond"
            }
          ]
        }
      },
      "id": "route-switch",
      "name": "Route Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        2450,
        250
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Lazy loading: Fetch full content for selected knowledge entries\n-- Only called when routing path needs full content\nSELECT\n  id,\n  title,\n  content,\n  metadata,\n  search_keywords,\n  created_at,\n  updated_at\nFROM knowledge_base\nWHERE id = ANY($1::uuid[]);",
        "options": {
          "queryReplacement": "={{ [Array.from(new Set($json.knowledge.map(k => k.id)))] }}"
        }
      },
      "id": "fetch-full-content",
      "name": "Fetch Full Knowledge Content",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        2450,
        100
      ],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Lazy loading: Fetches full content only when needed by routing paths"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.2: Auto-Respond Path Implementation\n// High confidence (>0.85), generate and post response automatically\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Task 5.8: Lightweight personalization updates\nfunction personalizeResponse(knowledgeContent, ticketData) {\n  let response = knowledgeContent;\n  \n  // Replace dates with current context\n  const today = new Date().toLocaleDateString('en-AU', { \n    weekday: 'long', \n    year: 'numeric', \n    month: 'long', \n    day: 'numeric' \n  });\n  response = response.replace(/{{current_date}}/g, today);\n  \n  // Replace property details\n  if (ticketData.entities?.propertyAddresses?.length > 0) {\n    response = response.replace(/{{property_address}}/g, ticketData.entities.propertyAddresses[0]);\n  }\n  \n  if (ticketData.entities?.lotNumbers?.length > 0) {\n    response = response.replace(/{{lot_number}}/g, ticketData.entities.lotNumbers[0]);\n  }\n  \n  // Personalize greeting\n  const requesterName = ticketData.requester?.name || 'there';\n  response = response.replace(/{{requester_name}}/g, requesterName);\n  \n  return response;\n}\n\n// Get the best knowledge entry\nconst bestKnowledge = knowledge[0];\nconst responseText = personalizeResponse(\n  bestKnowledge.summary || 'Response based on knowledge entry',\n  ticket\n);\n\n// Task 5.9: Claude quality check placeholder (to be implemented in Task 6.0)\n// For now, use knowledge content directly\nconst qualityCheckStatus = 'APPROVED';\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Hello ${ticket.requester?.name || 'there'},</p>\\n<p>${responseText}</p>\\n<p>Best regards,<br/>NSW Strata Management Team</p>`,\n  knowledgeId: bestKnowledge.id,\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  qualityCheck: qualityCheckStatus,\n  tags: ['auto-resolved', 'kb-reused'],\n  status: 4,  // Resolved\n  priority: ticket.priority,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "auto-respond-path",
      "name": "Path 1: Auto-Respond",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2650,
        100
      ],
      "notes": "Task 5.2: Auto-respond with high confidence, lightweight personalization"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.ticketId }}/reply",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"body\": $json.responseBody, \"from_email\": $env.FRESHDESK_FROM_EMAIL || \"support@company.com\"} }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "post-reply-freshdesk",
      "name": "Post Reply to Freshdesk",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        2850,
        100
      ],
      "credentials": {
        "freshdeskApi": {
          "id": "freshdesk-api",
          "name": "Freshdesk API"
        }
      },
      "notes": "Task 5.10: Post reply to Freshdesk ticket"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.ticketId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"status\": $json.status, \"tags\": $json.tags, \"custom_fields\": {\"knowledge_id\": $json.knowledgeId, \"confidence\": $json.confidence, \"routing_path\": $json.routingPath}} }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "update-ticket-status",
      "name": "Update Ticket Status & Tags",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        3050,
        100
      ],
      "credentials": {
        "freshdeskApi": {
          "id": "freshdesk-api",
          "name": "Freshdesk API"
        }
      },
      "notes": "Task 5.11 & 5.12: Update ticket status and append tags"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.3: Auto-Refine Path Implementation\n// Medium-high confidence (0.75-0.85), refine response with Claude\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Get top knowledge entries for refinement\nconst topKnowledge = knowledge.slice(0, 3);\n\n// Task 6.0: Will implement Claude refinement here\n// For now, generate draft that needs human review\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Draft response based on ${topKnowledge.length} knowledge entries</p><p>Requires human review before sending.</p>`,\n  knowledgeIds: topKnowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['ai-draft-review', 'requires-refinement'],\n  status: 3,  // Pending (not auto-resolved)\n  requiresHumanReview: true,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "auto-refine-path",
      "name": "Path 2: Auto-Refine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2650,
        200
      ],
      "notes": "Task 5.3: Auto-refine with Claude (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.4: Generate Draft Path Implementation\n// Medium confidence (0.50-0.75), generate draft response\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Use multiple knowledge entries to generate comprehensive draft\nconst relevantKnowledge = knowledge.slice(0, 5);\n\n// Task 6.0: Will implement Claude draft generation here\n// For now, create draft from knowledge summaries\n\nconst draftContent = relevantKnowledge.map((k, i) => \n  `${i+1}. ${k.title}: ${k.summary || 'See knowledge base'}`\n).join('\\n\\n');\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Draft response based on ${relevantKnowledge.length} knowledge entries:</p><p>${draftContent}</p><p>Requires human review and editing.</p>`,\n  knowledgeIds: relevantKnowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['ai-draft-review', 'medium-confidence'],\n  status: 3,  // Pending\n  requiresHumanReview: true,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "generate-draft-path",
      "name": "Path 3: Generate Draft",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2650,
        300
      ],
      "notes": "Task 5.4: Generate draft with Claude (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.5: Deep Research Path Implementation\n// Low confidence (<0.50), requires deep research\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Task 6.0: Will implement Perplexity deep research here\n// For now, escalate with research request\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>This ticket requires deep research.</p><p>Low confidence match (${(routing.confidence * 100).toFixed(1)}%). Escalating to human agent with research request.</p>`,\n  knowledgeIds: knowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['deep-research-required', 'low-confidence', 'escalated'],\n  status: 2,  // Open (assigned to research queue)\n  requiresHumanReview: true,\n  requiresResearch: true,\n  researchQuery: ticket.subject + ' ' + ticket.description,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "deep-research-path",
      "name": "Path 4: Deep Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2650,
        400
      ],
      "notes": "Task 5.5: Deep research with Perplexity (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.6: Immediate Escalation Path Implementation\n// Critical priority or high complexity, escalate immediately\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Determine escalation reason\nlet escalationReason = 'Unknown';\nif (ticket.priority === 'urgent') {\n  escalationReason = 'Critical priority - requires same-day response per SSMA Section 106';\n} else if (ticket.customFields?.complexity > 4) {\n  escalationReason = 'High complexity issue - requires expert review';\n} else if (routing.requiresHumanReview) {\n  escalationReason = 'Flagged for human review based on ticket analysis';\n}\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: null,  // No auto-response for escalations\n  knowledgeIds: knowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['escalated', 'critical', 'requires-human'],\n  status: 2,  // Open\n  priority: Math.min(ticket.priority + 1, 4),  // Increase priority\n  requiresHumanReview: true,\n  escalationReason: escalationReason,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "escalation-path",
      "name": "Path 5: Immediate Escalation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2650,
        500
      ],
      "notes": "Task 5.6: Immediate escalation for critical/complex tickets"
    },
    {
      "parameters": {
        "functionCode": "// Log error and send to error handler workflow\\nconst error = $input.first().json;\\n\\nconsole.error('Ticket processing failed:', error);\\n\\nreturn {\\n  error: true,\\n  message: 'Ticket processing failed',\\n  details: error,\\n  timestamp: new Date().toISOString()\\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1450,
        450
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Task 5.7: Track routing path statistics\n-- Insert metrics for dashboard and monthly analysis\nINSERT INTO system_metrics (metric_name, metric_value, category, subcategory, metadata, timestamp)\nVALUES \n  ('routing_path_count', 1, 'routing', $1, jsonb_build_object(\n    'ticket_id', $2,\n    'confidence', $3,\n    'knowledge_count', $4,\n    'priority', $5,\n    'category_hints', $6\n  ), NOW()),\n  ('routing_confidence', $3, 'quality', 'retrieval', jsonb_build_object(\n    'routing_path', $1,\n    'ticket_id', $2\n  ), NOW());\n\n-- Also update path counters (for Task 5.13 statistics)\nINSERT INTO system_metrics (metric_name, metric_value, category, subcategory, metadata, timestamp)\nVALUES ('path_' || $1 || '_total', 1, 'routing', 'counter', '{}'::jsonb, NOW())\nON CONFLICT DO NOTHING;",
        "options": {
          "queryReplacement": "={{ [\n  $json.routingPath,\n  $json.ticketId,\n  $json.confidence,\n  $json.knowledgeIds?.length || 0,\n  $json.priority,\n  JSON.stringify($json.ticket?.categoryHints || [])\n] }}"
        }
      },
      "id": "track-routing-stats",
      "name": "Track Routing Statistics",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3250,
        250
      ],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Task 5.7 & 5.13: Track routing statistics for monthly analysis"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - New Ticket": {
      "main": [
        [
          {
            "node": "Immediate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Immediate Response": {
      "main": [
        [
          {
            "node": "Verify Webhook Signature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Webhook Signature": {
      "main": [
        [
          {
            "node": "HMAC Signature Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HMAC Signature Verification": {
      "main": [
        [
          {
            "node": "Freshdesk - Get Ticket",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Freshdesk - Get Ticket": {
      "main": [
        [
          {
            "node": "Normalize and Extract Entities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize and Extract Entities": {
      "main": [
        [
          {
            "node": "NSW Strata Categorization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Ticket Data": {
      "main": [
        [
          {
            "node": "Generate Embedding (OpenAI)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding (OpenAI)": {
      "main": [
        [
          {
            "node": "Hybrid Search (Vector + Keyword)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hybrid Search (Vector + Keyword)": {
      "main": [
        [
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Fallback: Keyword-Only Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback: Keyword-Only Search": {
      "main": [
        [
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Ticket + Knowledge": {
      "main": [
        [
          {
            "node": "Decision Engine - Routing Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Decision Engine - Routing Logic": {
      "main": [
        [
          {
            "node": "Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Switch": {
      "main": [
        [
          {
            "node": "Path 1: Auto-Respond",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 2: Auto-Refine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 3: Generate Draft",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 4: Deep Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 5: Immediate Escalation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 1: Auto-Respond": {
      "main": [
        [
          {
            "node": "Post Reply to Freshdesk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post Reply to Freshdesk": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Ticket Status & Tags": {
      "main": [
        [
          {
            "node": "Track Routing Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 2: Auto-Refine": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 3: Generate Draft": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 4: Deep Research": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 5: Immediate Escalation": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NSW Strata Categorization": {
      "main": [
        [
          {
            "node": "Validate Ticket Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "error-handler"
  },
  "versionId": "1.0.0",
  "id": "main-ticket-processor",
  "meta": {
    "instanceId": "nsw-strata-automation"
  },
  "tags": [
    {
      "name": "production",
      "id": "prod"
    },
    {
      "name": "freshdesk",
      "id": "freshdesk"
    }
  ]
}
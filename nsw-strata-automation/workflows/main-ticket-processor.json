{
  "name": "Main Ticket Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "freshdesk-ticket",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-receiver",
      "name": "Webhook - New Ticket",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "freshdesk-new-ticket"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"status\": \"received\", \"ticket_id\": $json.ticket.id, \"timestamp\": new Date().toISOString()} }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "immediate-response",
      "name": "Immediate Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.headers['x-freshdesk-signature'] }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "verify-signature",
      "name": "Verify Webhook Signature",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Verify HMAC-SHA256 signature from Freshdesk\nconst crypto = require('crypto');\n\nconst webhookSecret = $env.FRESHDESK_WEBHOOK_SECRET || 'your-webhook-secret';\nconst signature = $json.headers['x-freshdesk-signature'];\nconst payload = JSON.stringify($json.body);\n\n// Calculate expected signature\nconst expectedSignature = crypto\n  .createHmac('sha256', webhookSecret)\n  .update(payload)\n  .digest('base64');\n\n// Verify signature\nconst isValid = signature === expectedSignature;\n\nif (!isValid) {\n  throw new Error('Invalid webhook signature');\n}\n\nreturn $json;"
      },
      "id": "signature-verification",
      "name": "HMAC Signature Verification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 250]
    },
    {
      "parameters": {
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.body.ticket.id }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "options": {
          "timeout": 10000
        }
      },
      "id": "get-ticket-details",
      "name": "Freshdesk - Get Ticket",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1050, 250]
    },
    {
      "parameters": {
        "functionCode": "// Normalize and enrich ticket text\nconst ticket = $json;\n\n// Remove HTML tags\nfunction stripHtml(html) {\n  if (!html) return '';\n  return html.replace(/<[^>]*>/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .trim();\n}\n\n// Extract NSW strata entities using regex\nfunction extractEntities(text) {\n  const entities = {\n    propertyAddresses: [],\n    lotNumbers: [],\n    strataPlanNumbers: [],\n    legislationReferences: [],\n    bylawNumbers: []\n  };\n\n  // Australian street addresses\n  const addressRegex = /\\d+\\s+[A-Za-z\\s]+(?:Street|St|Road|Rd|Avenue|Ave|Drive|Dr|Court|Ct|Place|Pl|Terrace|Tce|Parade|Pde|Boulevard|Blvd|Lane|Ln|Way|Highway|Hwy|Crescent|Cres),?\\s*(?:[A-Za-z\\s]+)?(?:NSW)?\\s*\\d{4}/gi;\n  entities.propertyAddresses = text.match(addressRegex) || [];\n\n  // Lot numbers (e.g., \"Lot 23\", \"Unit 5\", \"Apartment 12\")\n  const lotRegex = /(?:Lot|Unit|Apartment|Apt)\\s*#?\\s*(\\d+)/gi;\n  const lotMatches = text.matchAll(lotRegex);\n  for (const match of lotMatches) {\n    entities.lotNumbers.push(match[0]);\n  }\n\n  // Strata plan numbers (e.g., \"SP 12345\", \"Strata Plan 54321\")\n  const planRegex = /(?:SP|Strata\\s+Plan)\\s*#?\\s*(\\d+)/gi;\n  const planMatches = text.matchAll(planRegex);\n  for (const match of planMatches) {\n    entities.strataPlanNumbers.push(match[0]);\n  }\n\n  // NSW legislation references (e.g., \"SSMA 2015 Section 106\", \"Section 132 SSDA 2015\")\n  const legislationRegex = /(?:SSMA|SSDA)\\s*\\d{4}(?:\\s+Section\\s+\\d+)?|Section\\s+\\d+\\s+(?:SSMA|SSDA)\\s*\\d{4}/gi;\n  entities.legislationReferences = text.match(legislationRegex) || [];\n\n  // By-law numbers (e.g., \"By-law 3\", \"Model By-law 7\")\n  const bylawRegex = /(?:Model\\s+)?By-law\\s+#?\\s*(\\d+)/gi;\n  const bylawMatches = text.matchAll(bylawRegex);\n  for (const match of bylawMatches) {\n    entities.bylawNumbers.push(match[0]);\n  }\n\n  return entities;\n}\n\n// Extract keywords for NSW strata categories\nfunction extractKeywords(text) {\n  const keywords = {\n    maintenanceRepairs: ['roof', 'leak', 'plumbing', 'lift', 'elevator', 'repair', 'maintenance', 'damage', 'broken', 'malfunction', 'emergency'],\n    bylawCompliance: ['noise', 'parking', 'pet', 'dog', 'cat', 'smoking', 'rubbish', 'garbage', 'airbnb', 'short-term', 'letting', 'nuisance'],\n    financial: ['levy', 'levies', 'fee', 'payment', 'overdue', 'arrears', 'budget', 'insurance', 'claim'],\n    governance: ['meeting', 'AGM', 'EGM', 'committee', 'minutes', 'vote', 'resolution', 'quorum', 'by-law', 'bylaw'],\n    renovations: ['renovation', 'flooring', 'kitchen', 'bathroom', 'paint', 'tile', 'approval', 'alteration', 'work'],\n    disputes: ['complaint', 'dispute', 'NCAT', 'tribunal', 'mediation', 'conflict', 'neighbor', 'neighbour'],\n    security: ['security', 'access', 'CCTV', 'camera', 'safety', 'fire', 'hazard', 'lock', 'key'],\n    information: ['information', 'records', 'documents', 'certificate', 'strata plan', 'onboarding']\n  };\n\n  const lowerText = text.toLowerCase();\n  const matchedCategories = [];\n\n  for (const [category, words] of Object.entries(keywords)) {\n    for (const word of words) {\n      if (lowerText.includes(word.toLowerCase())) {\n        matchedCategories.push(category);\n        break;\n      }\n    }\n  }\n\n  return matchedCategories;\n}\n\n// Clean and concatenate subject + description\nconst subject = stripHtml(ticket.subject || '');\nconst description = stripHtml(ticket.description || '');\nconst normalizedText = `${subject}\\n\\n${description}`.trim();\n\n// Extract entities and keywords\nconst entities = extractEntities(normalizedText);\nconst categoryHints = extractKeywords(normalizedText);\n\n// Determine priority\nconst priorityMap = {\n  1: 'low',\n  2: 'medium',\n  3: 'high',\n  4: 'urgent'\n};\n\n// Build enriched ticket object\nconst enrichedTicket = {\n  // Original ticket data\n  ticketId: ticket.id,\n  subject: subject,\n  description: description,\n  normalizedText: normalizedText,\n  \n  // Metadata\n  priority: priorityMap[ticket.priority] || 'medium',\n  status: ticket.status,\n  created_at: ticket.created_at,\n  updated_at: ticket.updated_at,\n  due_by: ticket.due_by,\n  fr_due_by: ticket.fr_due_by,\n  \n  // Requester information\n  requester: {\n    id: ticket.requester_id,\n    name: ticket.requester?.name || null,\n    email: ticket.requester?.email || ticket.email || null,\n    phone: ticket.requester?.phone || null\n  },\n  \n  // Custom fields (property-specific)\n  customFields: ticket.custom_fields || {},\n  \n  // Extracted entities\n  entities: entities,\n  \n  // Category hints for classification\n  categoryHints: categoryHints,\n  \n  // Tags\n  tags: ticket.tags || [],\n  \n  // Attachments\n  hasAttachments: (ticket.attachments && ticket.attachments.length > 0),\n  attachmentCount: ticket.attachments?.length || 0,\n  \n  // Processing metadata\n  processingTimestamp: new Date().toISOString(),\n  textLength: normalizedText.length,\n  \n  // Full ticket object for reference\n  _original: ticket\n};\n\nreturn enrichedTicket;"
      },
      "id": "normalize-extract",
      "name": "Normalize and Extract Entities",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 250]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.textLength }}",
              "operation": "largerEqual",
              "value2": 10
            }
          ],
          "boolean": [
            {
              "value1": "={{ $json.ticketId !== undefined }}",
              "value2": true
            }
          ]
        }
      },
      "id": "validate-ticket",
      "name": "Validate Ticket Data",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1450, 250]
    },
    {
      "parameters": {
        "url": "={{ $env.OPENAI_API_URL || 'https://api.openai.com' }}/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.OPENAI_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "specifyBody": "json",
        "jsonBody": "={{ {\"model\": \"text-embedding-3-small\", \"input\": $json.normalizedText} }}",
        "options": {}
      },
      "id": "generate-embedding",
      "name": "Generate Embedding (OpenAI)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Hybrid search with lazy loading (summaries only)\n-- Task 4.14: Only fetch id, title, summary initially for performance\nWITH vector_search AS (\n  SELECT\n    id,\n    title,\n    metadata,\n    embedding <-> $1::vector AS distance,\n    1 - (embedding <-> $1::vector) AS similarity\n  FROM knowledge_base\n  WHERE metadata->>'status' = 'active'\n    -- Optional category filter\n    -- AND metadata->>'category' = $2\n  ORDER BY distance\n  LIMIT 10\n),\nkeyword_search AS (\n  SELECT\n    id,\n    title,\n    metadata,\n    similarity(COALESCE(metadata->>'summary', ''), $2) AS keyword_score\n  FROM knowledge_base\n  WHERE metadata->>'status' = 'active'\n    AND (COALESCE(metadata->>'summary', '') % $2 OR title % $2)\n  ORDER BY keyword_score DESC\n  LIMIT 10\n)\n-- Reciprocal Rank Fusion\nSELECT\n  kb.id,\n  kb.title,\n  kb.metadata->>'summary' AS summary,\n  kb.metadata->>'category' AS category,\n  kb.metadata->>'success_rate' AS success_rate,\n  kb.metadata,\n  COALESCE(vs.similarity, 0) AS vector_similarity,\n  COALESCE(ks.keyword_score, 0) AS keyword_score,\n  (\n    COALESCE(1.0 / (60 + vs_rank), 0) +\n    COALESCE(1.0 / (60 + ks_rank), 0)\n  ) AS combined_score\nFROM knowledge_base kb\nLEFT JOIN (\n  SELECT id, similarity, ROW_NUMBER() OVER (ORDER BY distance) AS vs_rank\n  FROM vector_search\n) vs ON kb.id = vs.id\nLEFT JOIN (\n  SELECT id, keyword_score, ROW_NUMBER() OVER (ORDER BY keyword_score DESC) AS ks_rank\n  FROM keyword_search\n) ks ON kb.id = ks.id\nWHERE vs.id IS NOT NULL OR ks.id IS NOT NULL\nORDER BY combined_score DESC\nLIMIT 5;",
        "options": {
          "queryReplacement": "={{ [$json.embedding, $json.normalizedText] }}",
          "nodeErrorWorkflow": "fallback-keyword-search"
        }
      },
      "id": "hybrid-search",
      "name": "Hybrid Search (Vector + Keyword)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1850, 200],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Task 4.15: Fallback keyword-only search when vector search fails\n-- Uses only pg_trgm trigram similarity for keyword matching\nSELECT\n  id,\n  title,\n  metadata->>'summary' AS summary,\n  metadata->>'category' AS category,\n  metadata->>'success_rate' AS success_rate,\n  metadata,\n  0 AS vector_similarity,\n  similarity(COALESCE(metadata->>'summary', title), $1) AS keyword_score,\n  similarity(COALESCE(metadata->>'summary', title), $1) AS combined_score\nFROM knowledge_base\nWHERE metadata->>'status' = 'active'\n  AND (COALESCE(metadata->>'summary', '') % $1 OR title % $1)\nORDER BY keyword_score DESC\nLIMIT 5;",
        "options": {
          "queryReplacement": "={{ [$json.normalizedText] }}"
        }
      },
      "id": "fallback-keyword-search",
      "name": "Fallback: Keyword-Only Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1850, 400],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Fallback search when hybrid search fails - uses trigram similarity only"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-ticket-knowledge",
      "name": "Merge Ticket + Knowledge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [2050, 250]
    },
    {
      "parameters": {
        "functionCode": "// Calculate confidence score and route decision\\nconst ticket = $input.first().json;\\nconst knowledgeEntries = $input.last().json;\\n\\n// Get highest similarity score\\nconst highestSimilarity = knowledgeEntries.length > 0 \\n  ? Math.max(...knowledgeEntries.map(k => k.vector_similarity || 0))\\n  : 0;\\n\\n// Count training samples for this category (simulated - would query training_examples table)\\nconst trainingSamples = 50; // TODO: Query actual training samples count\\n\\n// Determine routing path\\nlet routingPath = 'unknown';\\nlet requiresHumanReview = false;\\n\\nif (ticket.priority === 'urgent' || ticket.customFields?.complexity > 4) {\\n  routingPath = 'immediate-escalation';\\n  requiresHumanReview = true;\\n} else if (highestSimilarity > 0.85 && trainingSamples > 100 && !requiresHumanReview) {\\n  routingPath = 'auto-respond';\\n} else if (highestSimilarity >= 0.75 && highestSimilarity <= 0.85 && trainingSamples > 100) {\\n  routingPath = 'auto-refine';\\n} else if (highestSimilarity >= 0.50 && highestSimilarity < 0.75 && trainingSamples > 30) {\\n  routingPath = 'generate-draft';\\n} else if (highestSimilarity < 0.50) {\\n  routingPath = 'deep-research';\\n}\\n\\nreturn {\\n  ticket: ticket,\\n  knowledge: knowledgeEntries,\\n  routing: {\\n    path: routingPath,\\n    confidence: highestSimilarity,\\n    trainingSamples: trainingSamples,\\n    requiresHumanReview: requiresHumanReview,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
      },
      "id": "decision-engine",
      "name": "Decision Engine - Routing Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 250]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.routing.path }}",
              "value2": "auto-respond"
            }
          ]
        }
      },
      "id": "route-switch",
      "name": "Route Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [2450, 250]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Lazy loading: Fetch full content for selected knowledge entries\n-- Only called when routing path needs full content\nSELECT\n  id,\n  title,\n  content,\n  metadata,\n  search_keywords,\n  created_at,\n  updated_at\nFROM knowledge_base\nWHERE id = ANY($1::uuid[]);",
        "options": {
          "queryReplacement": "={{ [Array.from(new Set($json.knowledge.map(k => k.id)))] }}"
        }
      },
      "id": "fetch-full-content",
      "name": "Fetch Full Knowledge Content",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2450, 100],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Lazy loading: Fetches full content only when needed by routing paths"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.2: Auto-Respond Path Implementation\n// High confidence (>0.85), generate and post response automatically\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Task 5.8: Lightweight personalization updates\nfunction personalizeResponse(knowledgeContent, ticketData) {\n  let response = knowledgeContent;\n  \n  // Replace dates with current context\n  const today = new Date().toLocaleDateString('en-AU', { \n    weekday: 'long', \n    year: 'numeric', \n    month: 'long', \n    day: 'numeric' \n  });\n  response = response.replace(/{{current_date}}/g, today);\n  \n  // Replace property details\n  if (ticketData.entities?.propertyAddresses?.length > 0) {\n    response = response.replace(/{{property_address}}/g, ticketData.entities.propertyAddresses[0]);\n  }\n  \n  if (ticketData.entities?.lotNumbers?.length > 0) {\n    response = response.replace(/{{lot_number}}/g, ticketData.entities.lotNumbers[0]);\n  }\n  \n  // Personalize greeting\n  const requesterName = ticketData.requester?.name || 'there';\n  response = response.replace(/{{requester_name}}/g, requesterName);\n  \n  return response;\n}\n\n// Get the best knowledge entry\nconst bestKnowledge = knowledge[0];\nconst responseText = personalizeResponse(\n  bestKnowledge.summary || 'Response based on knowledge entry',\n  ticket\n);\n\n// Task 5.9: Claude quality check placeholder (to be implemented in Task 6.0)\n// For now, use knowledge content directly\nconst qualityCheckStatus = 'APPROVED';\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Hello ${ticket.requester?.name || 'there'},</p>\\n<p>${responseText}</p>\\n<p>Best regards,<br/>NSW Strata Management Team</p>`,\n  knowledgeId: bestKnowledge.id,\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  qualityCheck: qualityCheckStatus,\n  tags: ['auto-resolved', 'kb-reused'],\n  status: 4,  // Resolved\n  priority: ticket.priority,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "auto-respond-path",
      "name": "Path 1: Auto-Respond",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 100],
      "notes": "Task 5.2: Auto-respond with high confidence, lightweight personalization"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.ticketId }}/reply",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"body\": $json.responseBody, \"from_email\": $env.FRESHDESK_FROM_EMAIL || \"support@company.com\"} }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "post-reply-freshdesk",
      "name": "Post Reply to Freshdesk",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2850, 100],
      "credentials": {
        "freshdeskApi": {
          "id": "freshdesk-api",
          "name": "Freshdesk API"
        }
      },
      "notes": "Task 5.10: Post reply to Freshdesk ticket"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $env.FRESHDESK_DOMAIN }}/api/v2/tickets/{{ $json.ticketId }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "freshdeskApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\"status\": $json.status, \"tags\": $json.tags, \"custom_fields\": {\"knowledge_id\": $json.knowledgeId, \"confidence\": $json.confidence, \"routing_path\": $json.routingPath}} }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "update-ticket-status",
      "name": "Update Ticket Status & Tags",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3050, 100],
      "credentials": {
        "freshdeskApi": {
          "id": "freshdesk-api",
          "name": "Freshdesk API"
        }
      },
      "notes": "Task 5.11 & 5.12: Update ticket status and append tags"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.3: Auto-Refine Path Implementation\n// Medium-high confidence (0.75-0.85), refine response with Claude\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Get top knowledge entries for refinement\nconst topKnowledge = knowledge.slice(0, 3);\n\n// Task 6.0: Will implement Claude refinement here\n// For now, generate draft that needs human review\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Draft response based on ${topKnowledge.length} knowledge entries</p><p>Requires human review before sending.</p>`,\n  knowledgeIds: topKnowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['ai-draft-review', 'requires-refinement'],\n  status: 3,  // Pending (not auto-resolved)\n  requiresHumanReview: true,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "auto-refine-path",
      "name": "Path 2: Auto-Refine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 200],
      "notes": "Task 5.3: Auto-refine with Claude (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.4: Generate Draft Path Implementation\n// Medium confidence (0.50-0.75), generate draft response\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Use multiple knowledge entries to generate comprehensive draft\nconst relevantKnowledge = knowledge.slice(0, 5);\n\n// Task 6.0: Will implement Claude draft generation here\n// For now, create draft from knowledge summaries\n\nconst draftContent = relevantKnowledge.map((k, i) => \n  `${i+1}. ${k.title}: ${k.summary || 'See knowledge base'}`\n).join('\\n\\n');\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>Draft response based on ${relevantKnowledge.length} knowledge entries:</p><p>${draftContent}</p><p>Requires human review and editing.</p>`,\n  knowledgeIds: relevantKnowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['ai-draft-review', 'medium-confidence'],\n  status: 3,  // Pending\n  requiresHumanReview: true,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "generate-draft-path",
      "name": "Path 3: Generate Draft",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 300],
      "notes": "Task 5.4: Generate draft with Claude (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.5: Deep Research Path Implementation\n// Low confidence (<0.50), requires deep research\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Task 6.0: Will implement Perplexity deep research here\n// For now, escalate with research request\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: `<p>This ticket requires deep research.</p><p>Low confidence match (${(routing.confidence * 100).toFixed(1)}%). Escalating to human agent with research request.</p>`,\n  knowledgeIds: knowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['deep-research-required', 'low-confidence', 'escalated'],\n  status: 2,  // Open (assigned to research queue)\n  requiresHumanReview: true,\n  requiresResearch: true,\n  researchQuery: ticket.subject + ' ' + ticket.description,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "deep-research-path",
      "name": "Path 4: Deep Research",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 400],
      "notes": "Task 5.5: Deep research with Perplexity (to be implemented in Task 6.0)"
    },
    {
      "parameters": {
        "functionCode": "// Task 5.6: Immediate Escalation Path Implementation\n// Critical priority or high complexity, escalate immediately\n\nconst ticket = $json.ticket;\nconst knowledge = $json.knowledge;\nconst routing = $json.routing;\n\n// Determine escalation reason\nlet escalationReason = 'Unknown';\nif (ticket.priority === 'urgent') {\n  escalationReason = 'Critical priority - requires same-day response per SSMA Section 106';\n} else if (ticket.customFields?.complexity > 4) {\n  escalationReason = 'High complexity issue - requires expert review';\n} else if (routing.requiresHumanReview) {\n  escalationReason = 'Flagged for human review based on ticket analysis';\n}\n\nreturn {\n  ticketId: ticket.ticketId,\n  responseBody: null,  // No auto-response for escalations\n  knowledgeIds: knowledge.map(k => k.id),\n  confidence: routing.confidence,\n  routingPath: routing.path,\n  tags: ['escalated', 'critical', 'requires-human'],\n  status: 2,  // Open\n  priority: Math.min(ticket.priority + 1, 4),  // Increase priority\n  requiresHumanReview: true,\n  escalationReason: escalationReason,\n  processingTimestamp: new Date().toISOString()\n};"
      },
      "id": "escalation-path",
      "name": "Path 5: Immediate Escalation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 500],
      "notes": "Task 5.6: Immediate escalation for critical/complex tickets"
    },
    {
      "parameters": {
        "functionCode": "// Log error and send to error handler workflow\\nconst error = $input.first().json;\\n\\nconsole.error('Ticket processing failed:', error);\\n\\nreturn {\\n  error: true,\\n  message: 'Ticket processing failed',\\n  details: error,\\n  timestamp: new Date().toISOString()\\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 450]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Task 5.7: Track routing path statistics\n-- Insert metrics for dashboard and monthly analysis\nINSERT INTO system_metrics (metric_name, metric_value, category, subcategory, metadata, timestamp)\nVALUES \n  ('routing_path_count', 1, 'routing', $1, jsonb_build_object(\n    'ticket_id', $2,\n    'confidence', $3,\n    'knowledge_count', $4,\n    'priority', $5,\n    'category_hints', $6\n  ), NOW()),\n  ('routing_confidence', $3, 'quality', 'retrieval', jsonb_build_object(\n    'routing_path', $1,\n    'ticket_id', $2\n  ), NOW());\n\n-- Also update path counters (for Task 5.13 statistics)\nINSERT INTO system_metrics (metric_name, metric_value, category, subcategory, metadata, timestamp)\nVALUES ('path_' || $1 || '_total', 1, 'routing', 'counter', '{}'::jsonb, NOW())\nON CONFLICT DO NOTHING;",
        "options": {
          "queryReplacement": "={{ [\n  $json.routingPath,\n  $json.ticketId,\n  $json.confidence,\n  $json.knowledgeIds?.length || 0,\n  $json.priority,\n  JSON.stringify($json.ticket?.categoryHints || [])\n] }}"
        }
      },
      "id": "track-routing-stats",
      "name": "Track Routing Statistics",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [3250, 250],
      "credentials": {
        "postgres": {
          "id": "supabase-nsw-strata",
          "name": "Supabase - NSW Strata"
        }
      },
      "notes": "Task 5.7 & 5.13: Track routing statistics for monthly analysis"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - New Ticket": {
      "main": [
        [
          {
            "node": "Immediate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Immediate Response": {
      "main": [
        [
          {
            "node": "Verify Webhook Signature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Webhook Signature": {
      "main": [
        [
          {
            "node": "HMAC Signature Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HMAC Signature Verification": {
      "main": [
        [
          {
            "node": "Freshdesk - Get Ticket",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Freshdesk - Get Ticket": {
      "main": [
        [
          {
            "node": "Normalize and Extract Entities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize and Extract Entities": {
      "main": [
        [
          {
            "node": "Validate Ticket Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Ticket Data": {
      "main": [
        [
          {
            "node": "Generate Embedding (OpenAI)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding (OpenAI)": {
      "main": [
        [
          {
            "node": "Hybrid Search (Vector + Keyword)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hybrid Search (Vector + Keyword)": {
      "main": [
        [
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Fallback: Keyword-Only Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback: Keyword-Only Search": {
      "main": [
        [
          {
            "node": "Merge Ticket + Knowledge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Ticket + Knowledge": {
      "main": [
        [
          {
            "node": "Decision Engine - Routing Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Decision Engine - Routing Logic": {
      "main": [
        [
          {
            "node": "Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Switch": {
      "main": [
        [
          {
            "node": "Path 1: Auto-Respond",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 2: Auto-Refine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 3: Generate Draft",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 4: Deep Research",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Path 5: Immediate Escalation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 1: Auto-Respond": {
      "main": [
        [
          {
            "node": "Post Reply to Freshdesk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post Reply to Freshdesk": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Ticket Status & Tags": {
      "main": [
        [
          {
            "node": "Track Routing Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 2: Auto-Refine": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 3: Generate Draft": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 4: Deep Research": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Path 5: Immediate Escalation": {
      "main": [
        [
          {
            "node": "Update Ticket Status & Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "error-handler"
  },
  "versionId": "1.0.0",
  "id": "main-ticket-processor",
  "meta": {
    "instanceId": "nsw-strata-automation"
  },
  "tags": [
    {
      "name": "production",
      "id": "prod"
    },
    {
      "name": "freshdesk",
      "id": "freshdesk"
    }
  ]
}
